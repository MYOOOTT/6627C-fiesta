#pragma config(Sensor, in1,    mobileGoalPotentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  driveEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  liftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           frontRightMotor, tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port3,           rightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rearRightMotors, tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           frontLeftMotor, tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rearLeftMotors, tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

const int TOP_LIFT = -692;
bool mobileGoalPosition; //true = up, false = down
// up = 2800, down = 1500
const int TOP_MOBILE = 2800;
const int BOT_MOBILE = 1520;


void pre_auton() {
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...

	SensorValue[liftEncoder] = 0;
}


void stopMotors() {
	motor[frontRightMotor] = 0; //-
	motor[rearRightMotors] = 0; //-
	motor[frontLeftMotor] = 0; //+
	motor[rearLeftMotors] = 0; //+
}
void move1() {//1 = forward, -1 = backward
	int power = 127
'	motor[frontRightMotor] = (power * -1); //-
	motor[rearRightMotors] = (power * -1); //-
	motor[frontLeftMotor] = power; //+
	motor[rearLeftMotors] = power; //+
	waitInMilliseconds(80);
	stopMotors();
}

void turnRight() {
	motor[frontRightMotor] = -63;
	motor[rearRightMotors] = -63;
	motor[frontLeftMotor] = 63;
	motor[rearRightMotors] = 63;
	wait(.1);
}

task something() {
	motor[claw] = -127;
	wait(2);
	motor[claw] = 0;
}

task autonomous() {
	pre_auton();
	move1();
	motor[claw] = -127;
	while(SensorValue[liftEncoder] > -700) {
		motor[leftLift] = -127;
		motor[rightLift] = -127;
	}
	motor[leftLift] = 0;
	motor[rightLift] = 0;
	motor[claw] = 0;
	wait(1);
	move1();


}

bool onGoingTask;
task maxLift() {
	onGoingTask = true;
	if (abs(SensorValue[liftEncoder]) - TOP_LIFT > 200) {//if the lift is NOT RELATIVELY close to top already
		if(SensorValue[liftEncoder] < TOP_LIFT) { //when the lift is behind the robot
			while(SensorValue[liftEncoder] < TOP_LIFT - 60) { //until it is at the top
				motor[rightLift] = 127;
				motor[leftLift] = 127;
			}

			motor[rightLift] = -100;
			motor[leftLift] = -100;
			wait10Msec(2);
			motor[rightLift] = 0;
			motor[leftLift] = 0;
			onGoingTask = false;
			} else if (SensorValue[liftEncoder] > TOP_LIFT) { //when lift is in front of robot
			while(SensorValue[liftEncoder] > TOP_LIFT + 30) {
				motor[rightLift] = -127;
				motor[leftLift] = -127;
			}

			motor[rightLift] = 127;
			motor[leftLift] = 127;
			wait10Msec(2);
			motor[rightLift] = 0;
			motor[leftLift] = 0;
			onGoingTask = false;
		}
	}
}

task usercontrol () {
	clearTimer(T1);

	while(1 == 1)
	{
		//arcade control (left joystick)
		int left = vexRT[Ch4] + vexRT[Ch3];
		int right = vexRT[Ch4] - vexRT[Ch3];

		//creates a deadzone so that it doesn't move slightly to left/right/forward/backward
		if (abs(left) < 2)
			left = 0;
		if (abs(right) < 5)
			right = 0;

		motor[frontLeftMotor] = left;
		motor[rearLeftMotors] = left;

		motor[frontRightMotor] = right;
		motor[rearRightMotors] = right;

		//PRIMARY INTAKE (MANUAL)
		if (vexRT[Btn5U] == 1 && SensorValue[mobileGoalPotentiometer] < TOP_MOBILE) {
			motor[arm] = 127;
			} else if (vexRT[Btn5D] == 1 && SensorValue[mobileGoalPotentiometer] > BOT_MOBILE) {
			motor[arm] = -127;

			} else {
			motor[arm] = 0;
		}

		if (vexRT[Btn6U] == 1) {
			motor[rightLift] = 127;
			motor[leftLift] = 127;

			} else if (vexRT[Btn6D] == 1) {
			motor[rightLift] = -127;
			motor[leftLift] = -127;

			} else if (ongoingTask == true) {
			continue;
			}else {
			motor[rightLift] = 0;
			motor[leftLift] = 0;
		}


		if (vexRT[Btn8R] == 1) {
			motor[claw] = 127;

			} else if (vexRT[Btn8D] == 1) {
			motor[claw] = -127;
			} else {
			motor[claw] = 0;
		}

		if (vexRT(Btn8U) == 1) {
			startTask(maxLift);
		}
	}

}
