#pragma config(Sensor, in1,    mobileGoalPotentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  driveEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  liftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           frontRightMotor, tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port3,           rightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rearRightMotors, tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           frontLeftMotor, tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           leftLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rearLeftMotors, tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

const int TOP_LIFT = -692;
bool mobileGoalPosition; //true = up, false = down
// up = 2800, down = 1500
const int TOP_MOBILE = 2800;
const int BOT_MOBILE = 1400;


void pre_auton() {
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...

	SensorValue[liftEncoder] = 0;
}

task autonomous() {
	pre_auton();
}


task mobileGoalIntake() {
	if(mobileGoalPosition) { //move into down pos
		while(SensorValue[mobileGoalPotentiometer] > BOT_MOBILE){ //while the intake is above the "down" position
			motor[arm] = -127;
		}
		motor[arm] = 80;

	} else { //moves it into up pos
		while(SensorValue[mobileGoalPotentiometer] < TOP_MOBILE) { //while the intake is below the "up" position
			motor[arm] = 127;
		}
		motor[arm] = -80;
	}
	waitInMilliseconds(40);
	motor[arm] = 0;

}

task usercontrol () {
	while(1 == 1)
	{
		//arcade control (left joystick)
		int left = vexRT[Ch4] + vexRT[Ch3];
		int right = vexRT[Ch4] - vexRT[Ch3];

		//creates a deadzone so that it doesn't move slightly to left/right/forward/backward
		if (abs(left) < 2)
			left = 0;
		if (abs(right) < 5)
			right = 0;

		motor[frontLeftMotor]  = left;
		motor[rearLeftMotors] = left;

		motor[frontRightMotor]  = right;
		motor[rearRightMotors] = right;

		//PRIMARY INTAKE (AUTOMATIC)
		if (vexRT[Btn5U] == 1) {
			mobileGoalPosition = false; //assume it's in down position already
			startTask(mobileGoalIntake);

			} else if (vexRT[Btn5D] == 1) {
			mobileGoalPosition = true; //assume it's in up pos already
			startTask(mobileGoalIntake);
		}

		if (vexRT[Btn6U] == 1) {
			motor[rightLift] = 127;
			motor[leftLift] = 127;

			} else if (vexRT[Btn6D] == 1) {
			motor[rightLift] = -127;
			motor[leftLift] = -127;

			} else {
			motor[rightLift] = 0;
			motor[leftLift] = 0;
		}


		if (vexRT[Btn8R] == 1) {
			motor[claw] = 127;

			} else if (vexRT[Btn8D] == 1) {
			motor[claw] = -127;

			} else {
			motor[claw] = 0;
		}

		if (vexRT(Btn8U) == 1) {
			if (abs(SensorValue[liftEncoder]) - TOP_LIFT > 200) {//if the lift is NOT RELATIVELY close to top already
				if(SensorValue[liftEncoder] < TOP_LIFT) { //when the lift is behind the robot
					while(SensorValue[liftEncoder] != TOP_LIFT) { //until it is at the top
						motor[rightLift] = 127;
						motor[leftLift] = 127;
					}

					motor[rightLift] = -100;
					motor[leftLift] = -100;
					wait10Msec(2);
					motor[rightLift] = 0;
					motor[leftLift] = 0;

					} else if (SensorValue[liftEncoder] > TOP_LIFT) { //when lift is in front of robot
						while(SensorValue[liftEncoder] != TOP_LIFT) {
							motor[rightLift] = -127;
							motor[leftLift] = -127;
						}

					motor[rightLift] = 127;
					motor[leftLift] = 127;
					wait10Msec(5);
					motor[rightLift] = 0;
					motor[leftLift] = 0;

				}
			}
		}
	}

}
